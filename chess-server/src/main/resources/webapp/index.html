<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Five Chess</title>
    <script src="js/jquery-3.4.1.min.js"></script>
    <script src="js/fabric-3.2.0.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <canvas id="chessCanvas" width="420" height="420">
        Your browser does not support the HTML5 canvas tag.
    </canvas>
    <script>
        // settings
        const startLeft = 40;
        const startTop = 40;
        const cellNums = 12;
        const cellWidth = 30;
        const endLeft = startLeft + (cellNums - 1) * cellWidth;
        const endTop = startTop + (cellNums - 1) * cellWidth;
        const chessRadius = 10;

        // chess objects
        var chessTable = new Map();
        var chessCount = 0;
        const sideColor = {
            white: "white",
            black: "black"
        };

        // websocket client
        var ws;
        var sessionId = "123";
        var pageURL = $(location).attr("href");
        const stats = {
            disconnect: "disconnect",
            init: "init",
            ready: "ready",
            process: "process",
            terminal: "terminal"
        };
        var stat = stats.disconnect; // disconnect -> init -> ready -> process -> terminal
        var side = sideColor.white;

        $(document).ready(function() {
            console.log("page url: ", pageURL);
            var location = getLocation(pageURL);
            var query = getJsonFromUrl(location.search);
            var roomId = query["room"]
            console.log("roomId: ", roomId);
            if (roomId !== undefined && roomId !== "") {
                sessionId = roomId;
            }
            var wsUri = getWsUri(location);
            console.log("ws uri: ", wsUri);
            ws = connectToWS(wsUri, onMsgCallback = msgListen);
        });

        const canvas = new fabric.Canvas('chessCanvas');
        drawCells(canvas);
        drawChesses(canvas, chessTable);

        document.addEventListener('click', function(event) {
            if (stat !== stats.ready && stat !== stats.process) {
                //not ready for start
                return;
            }

            if (!isMyTurn()) {
                // not my turn
                return;
            }

            var coordinate = toCoordinate(event.clientX, event.clientY);
            console.log(coordinate.x + ', ' + coordinate.y);
            var key = genKey(coordinate.x, coordinate.y);

            if (chessTable.has(key)) {
                console.log("already contains key: ", key);
                return;
            }

            var chess = {
                x: coordinate.x,
                y: coordinate.y,
                side: side
            };

            send(ws, JSON.stringify({
                type: stats.process,
                sessionId: sessionId,
                chesses: [chess, ]
            }))
        });

        function connectToWS(endpoint, onMsgCallback) {
            var ws = new WebSocket(endpoint);

            ws.onmessage = onMsgCallback;
            ws.onopen = function(evt) {
                console.log("onopen.");
                send(ws, JSON.stringify({
                    type: stats.init,
                    sessionId: sessionId
                }));
            };
            ws.onclose = function(evt) {
                console.log("onclose.");
                stat = stats.disconnect;
            };
            ws.onerror = function(evt) {
                console.log("Error!");
            };
            return ws;
        }

        function send(ws, msg) {
            console.log("send msg: ", msg);
            ws.send(msg);
        }

        function msgListen(event) {
            var leng;
            if (event.data.size === undefined) {
                leng = event.data.length
            } else {
                leng = event.data.size
            }
            console.log("onmessage. size: " + leng + ", content: " + event.data);
            var dto = JSON.parse(event.data);
            if (dto["type"] === stats.process) {
                var chesses = dto["chesses"];
                chessCount = dto["count"];
                stat = stats.process;

                chesses.forEach(function(chess) {
                    console.log(chess);
                    var key = genKey(chess.x, chess.y);
                    chessTable.set(key, chess)
                });

                drawChesses(canvas, chessTable);
            } else if (dto["type"] === stats.init) {
                var chesses = dto["chesses"];
                chessCount = dto["count"];
                side = dto["side"];
                stat = stats.ready;

                chesses.forEach(function(chess) {
                    console.log(chess);
                    var key = genKey(chess.x, chess.y);
                    chessTable.set(key, chess)
                });

                drawChesses(canvas, chessTable);
            } else {
                console.log("undefined message type: ", dto);
            }
        }


        function genKey(x, y) {
            return x + "_" + y;
        }

        function drawChesses(canvas, chessTable) {
            chessTable.forEach(function(value, key, map) {
                var distance = toDistance(value.x, value.y);
                const circle = makeCircle(distance.left, distance.top, sideColor[value.side]);
                canvas.add(circle);
            });
        }


        function drawCells(canvas) {
            for (var i = 0; i < cellNums; i++) {
                var hLine = makeLine([startLeft, startTop + i * cellWidth, endLeft, startTop + i * cellWidth]);
                var vLine = makeLine([startLeft + i * cellWidth, startTop, startLeft + i * cellWidth, endTop]);
                canvas.add(hLine);
                canvas.add(vLine);
            }
        }

        function makeLine(coords) {
            return new fabric.Line(coords, {
                fill: 'gray',
                stroke: '#b22',
                strokeWidth: 1,
                selectable: false,
                evented: false,
            });
        }

        function makeCircle(left, top, color = 'white') {
            return new fabric.Circle({
                left: left,
                top: top,
                strokeWidth: 1,
                radius: chessRadius,
                fill: color,
                stroke: '#666',
                selectable: false,
                evented: false,
            });
        }

        function toCoordinate(left, top) {
            var _x = (left - startLeft) / cellWidth;
            var _y = (top - startTop) / cellWidth;
            return {
                x: Math.floor(_x),
                y: Math.floor(_y),
            };
        }

        function toDistance(x, y) {
            var _x = startLeft + x * cellWidth - chessRadius;
            var _y = startTop + y * cellWidth - chessRadius;
            return {
                left: _x,
                top: _y,
            }
        }

        function getLocation(href) {
            //parser.href = "http://example.com:3000/pathname/?search=test#hash";
            // parser.protocol; // => "http:"
            // parser.host;     // => "example.com:3000"
            // parser.hostname; // => "example.com"
            // parser.port;     // => "3000"
            // parser.pathname; // => "/pathname/"
            // parser.hash;     // => "#hash"
            // parser.search;   // => "?search=test"
            // parser.origin;   // => "http://example.com:3000"

            var l = document.createElement("a");
            l.href = href;
            return l;
        }

        function getWsUri(location) {
            var wsUri = "ws://" + location.hostname + ":" + location.port + "/ws";
            return wsUri;
        }

        function getJsonFromUrl(url) {
            var query = url.substr(1);
            var result = {};
            query.split("&").forEach(function(part) {
                var item = part.split("=");
                result[item[0]] = decodeURIComponent(item[1]);
            });
            return result;
        }

        function isMyTurn() {
            if (side === sideColor.black && chessCount % 2 === 0) {
                return true;
            } else if (side === sideColor.white && chessCount % 2 === 1) {
                return true;
            } else {
                return false;
            }
        }
    </script>
</body>

</html>